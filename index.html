<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Team Plinko Battle</title>
  <style>
    body {
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        font-family: 'Arial', sans-serif;
    }
    #canvas {
        border: 4px solid #fff;
        border-radius: 10px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        background: #1a1a2e;
    }
    .game-container {
        display: flex;
        flex-direction: column;
        gap: 20px;
        align-items: center;
    }
    .teams {
        display: flex;
        gap: 40px;
        width: 600px;
        justify-content: space-between;
    }
    .team {
        flex: 1;
        padding: 20px;
        border-radius: 10px;
        color: white;
        text-align: center;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        text-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    .team-red {
        background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
    }
    .team-blue {
        background: linear-gradient(135deg, #4ecdc4, #44a3d5);
    }
    .team h2 {
        margin: 0 0 10px 0;
        font-size: 24px;
        text-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    .team .balance {
        font-size: 32px;
        font-weight: bold;
        margin: 10px 0;
        text-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    .team .label {
        font-size: 14px;
        opacity: 0.9;
        text-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    .controls {
        display: flex;
        gap: 15px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: center;
    }
    button {
        padding: 12px 24px;
        font-size: 16px;
        font-weight: bold;
        border: none;
        border-radius: 8px;
        color: white;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }
    button:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }
    button:active:not(:disabled) {
        transform: translateY(0);
    }
    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    .drop-btn {
        background: linear-gradient(135deg, #41a945 0%, #acfa70 100%);
    }
    .boost-btn-red {
        background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
    }
    .boost-btn-blue {
        background: linear-gradient(135deg, #4ecdc4, #44a3d5);
    }
    .reset-btn {
        background: linear-gradient(135deg, #95a5a6, #7f8c8d);
    }
    .set-bal-btn {
        background: linear-gradient(135deg, #e67e22, #d35400);
        margin-top: 10px;
        margin-bottom: 20px;
    }
    .info {
        background: rgba(255,255,255,0.1);
        padding: 15px 25px;
        border-radius: 10px;
        color: white;
        text-align: center;
        backdrop-filter: blur(10px);
        max-width: 600px;
        margin: 75px;
    }
    .pot {
        background: linear-gradient(135deg, #f39c12, #f1c40f);
        padding: 20px;
        border-radius: 10px;
        color: white;
        text-align: center;
        font-size: 20px;
        font-weight: bold;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        text-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    .pot .amount {
        font-size: 32px;
        margin-top: 20px;
        text-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    .bet-input {
        display: flex;
        gap: 10px;
        align-items: center;
        background: rgba(255,255,255,0.1);
        padding: 10px 20px;
        border-radius: 8px;
    }
    .bet-input input {
        width: 100px;
        padding: 8px;
        font-size: 16px;
        border: 2px solid white;
        border-radius: 5px;
        text-align: center;
    }
    .bet-input label {
        color: white;
        font-weight: bold;
    }
    .title {
        color: white;
        font-size: 50px;
        font-weight: bold;
        border: 0px solid #000;
        border-radius: 20px;
        text-shadow: 0 4px 20px rgba(0,0,0,1);
        padding: 20px;
        margin: 30px;
    }
    .house {
        background: rgba(255,255,255,0.1);
        padding: 15px 25px;
        border-radius: 10px;
        backdrop-filter: blur(10px);
        max-width: 600px;
        margin: 100px;
        color: white;
    }
    .house-controls {
        font-size: 24px;
        font-weight: bold;
        margin: 20px;
    }
    .house-selection {
        color: white;
        font-weight: bold;
        margin: 5px;
    }
    .change-input {
        margin: 10px 0;
    }
    .change-input input, select {
        margin-left: 10px;
        padding: 5px;
        border-radius: 5px;
    }
    .house-bal {
        background: linear-gradient(135deg, #f39c12, #f1c40f);
        padding: 20px;
        border-radius: 10px;
        color: white;
        text-align: center;
        font-size: 20px;
        font-weight: bold;
        box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        text-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    .house-bal .amount {
        font-size: 32px;
        margin-top: 20px;
        text-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    /* Container positioning */
    #audio-slider-container {
        position: fixed;
        left: 50px;
        bottom: 50px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 8px;
        padding: 10px;
        background: rgba(0,0,0,0.35);
        border-radius: 8px;
        backdrop-filter: blur(6px);
    }

    /* Label and number styling */
    .audio-label {
        font-size: 14px;
        color: white;
        font-weight: 600;
    }

    #audio-value {
        font-size: 14px;
        color: white;
        font-weight: 500;
    }

    /* Vertical slider styling */
    #audio-slider {
        writing-mode: bt-lr;        /* vertical orientation */
        -webkit-appearance: slider-vertical;
        width: 20px;
        height: 150px;
    }

    /* Make it easier to use on mobile */
    @media (max-width: 600px) {
        #audio-slider-container {
            left: 30px;
            bottom: 30px;
            padding: 8px;
            gap: 6px;
        }

        #audio-slider {
            height: 200px;
            width: 24px;
        }

        .audio-label,
        #audio-value {
            font-size: 16px;
        }
    }

  </style>
</head>
<body>
<div class="title">
  Plinko PvP
</div>
<div class="game-container">
  <div class="teams">
    <div class="team team-red">
      <h2>Red Team</h2>
      <div class="label">Balance</div>
      <div class="balance" id="redBalance">$1000</div>
    </div>
    <div class="pot">
      <div>üí∞ POT</div>
      <div class="amount" id="potAmount">$0</div>
    </div>
    <div class="team team-blue">
      <h2>Blue Team</h2>
      <div class="label">Balance</div>
      <div class="balance" id="blueBalance">$1000</div>
    </div>
  </div>

  <canvas id="canvas"></canvas>

  <div class="controls">
    <div class="bet-input">
      <label>Bet Amount:</label>
      <input type="number" id="betAmount" value="100" min="1" max="1000">
    </div>
  </div>

  <div class="controls">
    <button class="drop-btn" onclick="dropBothBalls()" id="dropBtn">Start Round ($<span id="betDisplay">100</span> each)</button>
    <button class="reset-btn" onclick="reset()">Reset Game</button>
  </div>

  <!--
  <div class="controls">
    <button class="boost-btn-red" onclick="boost('right')" id="redBoostBtn" disabled>Boost Right (Red) ‚Üí</button>
    <button class="boost-btn-blue" onclick="boost('left')" id="blueBoostBtn" disabled>‚Üê Boost Left (Blue)</button>
  </div>
  -->
  <!--
  <div class="info">
    <div class="house-controls"><strong>How to Play:</strong></div>
    <div><strong>Controls:</strong> Space = Start Round, Left Arrow = Boost Left, Right Arrow = Boost Right</div>
    <div><strong>Fixed FPS:</strong> 60 FPS for consistent physics across all browsers</div>
    <div><strong>Payouts:</strong></div>
    <div>‚Ä¢ <strong>Jackpot (outer):</strong> Win entire pot! | <strong>Center:</strong> 50% back, 25% to pot, 25% house</div>
    <div>‚Ä¢ <strong>Landing on opponent's side:</strong> Take % of their bet | <strong>Your side:</strong> Give % of your bet</div>
    <div>‚Ä¢ Max take/give is 50% each, total ‚â§100% of bet</div>
  </div>
  -->
</div>

<div class="house">
  <div class="house-controls"> House Controls:</div>
  <div class="house-selection">
    <label for="house-teams">Choose a Team:</label>
    <select name="teams" id="house-teams">
      <option value="red">red</option>
      <option value="blue">blue</option>
    </select>
  </div>
  <div class="change-input">
    <label><strong>Balance Amount:</strong></label>
    <input type="number" id="house-amount" value="100" min="1" max="1000">
  </div>
  <button class="set-bal-btn" onclick="setBalance()" id="setBalBtn">Set Balance</button>
  <div class="house-bal">
    <div>House Balance</div>
    <div class="amount" id="house-bal">$0</div>
  </div>
</div>

<div id="audio-slider-container">
  <div class="audio-label">Volume</div>
  <input id="audio-slider" type="range" min="0" max="100" value="100" orient="vertical">
  <div id="audio-value">100</div>
</div>


<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  canvas.width = 600;
  canvas.height = 700;

  const FIXED_FPS = 60;
  const FRAME_TIME = 1000 / FIXED_FPS;
  const GRAVITY = 0.4 * (60 / FIXED_FPS);
  const BOUNCE = 0.6;
  const FRICTION = 0.98;
  const PEG_RADIUS = 5;
  const BALL_RADIUS = 8;
  const BOOST_LINE = 350;
  const BOOST_LINE_UPPER = 150;
  const BOOST_FORCE = 8 * (60 / FIXED_FPS);


  // ============================= MEDIA =======================================
  const audio_plink = new Audio("sounds/plink.mp3");
  const audio_plink_small = new Audio("sounds/plink_small.mp3");
  // audio_plink.play();

  let masterVolume = 1.0;

  const audioSlider = document.getElementById("audio-slider");
  const audioValue = document.getElementById("audio-value");

  audioSlider.addEventListener("input", () => {
      masterVolume = audioSlider.value / 100;
      audioValue.textContent = audioSlider.value;
  });

  // ===========================================================================


  const pegs = [];
  let activeBalls = [];
  let boostUsed = {};
  let currentBet = 0;

  let redBalance = 500;
  let blueBalance = 500;
  let pot = 0;
  let houseTotal = 0;

  let lastTime = 0;
  let accumulatedTime = 0;
  let animationFrameId = null;
  let isAnimationRunning = false;

  const slotConfig = [
      { id: -5, type: 'jackpot', team: 'red', label: 'JACKPOT' },
      { id: -4, type: 'points', team: 'red', takePercent: 50, givePercent: 10 },
      { id: -3, type: 'points', team: 'red', takePercent: 40, givePercent: 20 },
      { id: -2, type: 'points', team: 'red', takePercent: 30, givePercent: 30 },
      { id: -1, type: 'points', team: 'red', takePercent: 20, givePercent: 40 },
      { id: 0, type: 'center', label: 'CENTER' },
      { id: 1, type: 'points', team: 'blue', takePercent: 20, givePercent: 40 },
      { id: 2, type: 'points', team: 'blue', takePercent: 30, givePercent: 30 },
      { id: 3, type: 'points', team: 'blue', takePercent: 40, givePercent: 20 },
      { id: 4, type: 'points', team: 'blue', takePercent: 50, givePercent: 10 },
      { id: 5, type: 'jackpot', team: 'blue', label: 'JACKPOT' }
  ];

  document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
          e.preventDefault();
          dropBothBalls();
      } else if (e.code === 'ArrowLeft') {
          e.preventDefault();
          boost('b_left');
          updateUI();
      } else if (e.code === 'ArrowRight') {
          e.preventDefault();
          boost('b_right');
          updateUI();
      } else if (e.code === 'ArrowUp') {
          e.preventDefault();
          boost('b_up');
          updateUI();
      } else if (e.code === 'ArrowDown') {
          e.preventDefault();
          boost('b_down');
          updateUI();
      } else if (e.code === 'KeyA') {
          e.preventDefault();
          boost('r_left');
          updateUI();
      } else if (e.code === 'KeyD') {
          e.preventDefault();
          boost('r_right');
          updateUI();
      } else if (e.code === 'KeyW') {
          e.preventDefault();
          boost('r_up');
          updateUI();
      } else if (e.code === 'KeyS') {
          e.preventDefault();
          boost('r_down');
          updateUI();
      }
  });

  document.getElementById('betAmount').addEventListener('input', function() {
      const bet = Math.max(1, parseInt(this.value) || 1);
      document.getElementById('betDisplay').textContent = bet;
  });

  function initPegs() {
      const rows = 12;
      const startY = 100;
      const rowSpacing = 45;
      const pegSpacing = 45;

      for (let row = 0; row < rows; row++) {
          const pegsInRow = row + 3;
          const rowWidth = (pegsInRow - 1) * pegSpacing;
          const startX = (canvas.width - rowWidth) / 2;

          for (let i = 0; i < pegsInRow; i++) {
              pegs.push({
                  x: startX + i * pegSpacing,
                  y: startY + row * rowSpacing,
                  radius: PEG_RADIUS
              });
          }
      }
  }

  class Ball {
      constructor(x, y, team, id) {
          this.x = x;
          this.y = y;
          this.vx = (Math.random() - 0.5) * 2;
          this.vy = 0;
          this.radius = BALL_RADIUS;
          this.team = team;
          this.color = team === 'red' ? '#ff6b6b' : '#4ecdc4';
          this.active = true;
          this.id = id;
      }

      update(deltaTime) {
          if (!this.active) return;

          this.vy += GRAVITY;
          this.vx *= FRICTION;
          this.vy *= FRICTION;
          this.x += this.vx;
          this.y += this.vy;

          pegs.forEach(peg => {
              const dx = this.x - peg.x;
              const dy = this.y - peg.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              const minDist = this.radius + peg.radius;

              if (dist < minDist) {
                  const angle = Math.atan2(dy, dx);
                  const targetX = peg.x + Math.cos(angle) * minDist;
                  const targetY = peg.y + Math.sin(angle) * minDist;

                  this.x = targetX;
                  this.y = targetY;

                  const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                  this.vx = Math.cos(angle) * speed * BOUNCE;
                  this.vy = Math.sin(angle) * speed * BOUNCE;

                  // --- AUDIO CONTROL LOGIC (more aggressive falloff) ---
                  const impactThreshold = 0.5;        // cutoff for silence
                  const maxSpeed = 10;                // speed that corresponds to full volume

                  // Normalized speed (0‚Äì1)
                  let t = Math.min(1, Math.max(0, speed / maxSpeed));

                  // Quadratic falloff (aggressive decrease)
                  // t^2 grows slow at low speeds and ramps up late
                  const volume = t * t;

                  if (speed >= impactThreshold) {
                      audio_plink_small.volume = volume * masterVolume;
                      audio_plink_small.currentTime = 0;
                      audio_plink_small.play();
                  }
              }
          });

          if (this.x - this.radius < 0) {
              this.x = this.radius;
              this.vx *= -BOUNCE;
          } else if (this.x + this.radius > canvas.width) {
              this.x = canvas.width - this.radius;
              this.vx *= -BOUNCE;
          }

          if (this.y + this.radius > canvas.height - 80) {
              this.y = canvas.height - 80 - this.radius;
              this.vy = 0;
              this.vx *= 0.8;

              if (Math.abs(this.vx) < 0.5 && Math.abs(this.vy) < 0.5) {
                  if (this.active) {
                      const slotIndex = Math.floor(this.x / (canvas.width / slotConfig.length));
                      if (slotIndex >= 0 && slotIndex < slotConfig.length) {
                          handleSlotLanding(slotConfig[slotIndex], this.team);
                      }
                      this.active = false;
                      delete boostUsed[this.id];
                      setTimeout(() => {
                          activeBalls = activeBalls.filter(ball => ball !== this);
                          updateUI();
                      }, 100);
                  }
              }
          }

          // updateBoostButtons();
      }

      draw() {
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
          ctx.fillStyle = this.color;
          ctx.fill();
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
          ctx.lineWidth = 2;
          ctx.stroke();
      }
  }

  function handleSlotLanding(slot, team) {
      const bet = currentBet;

      if (slot.type === 'jackpot') {
          if (team === 'red') {
              redBalance += pot + bet;
          } else {
              blueBalance += pot + bet;
          }
          showMessage(`${team.toUpperCase()} WINS THE JACKPOT! +$${pot}`, slot.team);
          pot = 0;
      } else if (slot.type === 'center') {
          const playerReturn = Math.floor(bet * 0.5);
          const potAmount = Math.floor(bet * 0.45);
          const houseAmount = Math.floor(bet * 0.05);

          if (team === 'red') {
              redBalance += playerReturn;
          } else {
              blueBalance += playerReturn;
          }
          pot += potAmount;
          houseTotal += houseAmount;

          showMessage(`${team.toUpperCase()} Center! +$${playerReturn} (Pot +$${potAmount})`, 'neutral');
      } else if (slot.type === 'points') {
          const isOwnSide = (team === slot.team);

          if (isOwnSide) {
              const giveAmount = Math.floor(bet * slot.givePercent / 100);
              const keepAmount = bet - giveAmount;

              if (team === 'red') {
                  redBalance += keepAmount;
                  blueBalance += giveAmount;
              } else {
                  blueBalance += keepAmount;
                  redBalance += giveAmount;
              }

              const potContribution = Math.floor(bet * 0.05);
              pot += potContribution;

              showMessage(`${team.toUpperCase()} keeps $${keepAmount}, gives $${giveAmount}`, team);
          } else {
              const takeAmount = Math.floor(bet * slot.takePercent / 100);

              if (team === 'red') {
                  if (blueBalance >= takeAmount) {
                      blueBalance -= takeAmount;
                      redBalance += takeAmount + bet;
                  } else {
                      redBalance += bet;
                  }
              } else {
                  if (redBalance >= takeAmount) {
                      redBalance -= takeAmount;
                      blueBalance += takeAmount + bet;
                  } else {
                      blueBalance += bet;
                  }
              }

              const potContribution = Math.floor(bet * 0.05);
              pot += potContribution;

              showMessage(`${team.toUpperCase()} takes $${takeAmount} from opponent!`, team);
          }
      }

      updateUI();
  }

  function showMessage(text, team) {
      const messageDiv = document.createElement('div');
      messageDiv.textContent = text;
      messageDiv.style.position = 'fixed';
      messageDiv.style.top = '50%';
      messageDiv.style.left = '50%';
      messageDiv.style.transform = 'translate(-50%, -50%)';
      messageDiv.style.padding = '20px 40px';
      messageDiv.style.borderRadius = '10px';
      messageDiv.style.fontSize = '24px';
      messageDiv.style.fontWeight = 'bold';
      messageDiv.style.color = 'white';
      messageDiv.style.zIndex = '1000';
      messageDiv.style.boxShadow = '0 10px 40px rgba(0,0,0,0.5)';

      if (team === 'red') {
          messageDiv.style.background = 'linear-gradient(135deg, #ff6b6b, #ee5a6f)';
          messageDiv.style.transform = 'translate(100%, -50%)';
          messageDiv.style.padding = '20px 30px';
      } else if (team === 'blue') {
          messageDiv.style.background = 'linear-gradient(135deg, #4ecdc4, #44a3d5)';
          messageDiv.style.transform = 'translate(-200%, -50%)';
          messageDiv.style.padding = '20px 30px';
      } else {
          messageDiv.style.background = 'linear-gradient(135deg, #f39c12, #f1c40f)';
      }

      document.body.appendChild(messageDiv);

      setTimeout(() => {
          messageDiv.style.transition = 'opacity 0.5s';
          messageDiv.style.opacity = '0';
          setTimeout(() => messageDiv.remove(), 500);
      }, 2000);
  }

  function dropBothBalls() {
      if (activeBalls.length > 0) return;

      const bet = Math.max(1, parseInt(document.getElementById('betAmount').value) || 100);

      if (redBalance < bet) {
          showMessage('Red Team: Insufficient balance!', 'red');
          return;
      }
      if (blueBalance < bet) {
          showMessage('Blue Team: Insufficient balance!', 'blue');
          return;
      }

      redBalance -= bet;
      blueBalance -= bet;
      currentBet = bet;

      const redBallId = Date.now() + 'red';
      const blueBallId = Date.now() + 'blue';

      const redBall = new Ball(canvas.width / 2 - 20, 20, 'red', redBallId);
      const blueBall = new Ball(canvas.width / 2 + 20, 20, 'blue', blueBallId);

      activeBalls.push(redBall, blueBall);
      boostUsed[redBallId] = false;
      boostUsed[blueBallId] = false;

      if (!isAnimationRunning) {
          startAnimation();
      }

      updateUI();
  }

  function boost(direction) {
      for (const ball of activeBalls) {
          if (!ball.active || boostUsed[ball.id] || ball.y > BOOST_LINE || ball.y < BOOST_LINE_UPPER) continue;

          if (direction === 'b_left' && ball.team === 'blue') {
              ball.vx -= BOOST_FORCE;
              boostUsed[ball.id] = true;
              showMessage('BOOST!', 'blue');
              break;
          } else if (direction === 'b_right' && ball.team === 'blue') {
              ball.vx += BOOST_FORCE;
              boostUsed[ball.id] = true;
              showMessage('BOOST!', 'blue');
              break;
          } else if (direction === 'b_up' && ball.team === 'blue') {
              ball.vy -= BOOST_FORCE;
              boostUsed[ball.id] = true;
              showMessage('BOOST!', 'blue');
              break;
          } else if (direction === 'b_down' && ball.team === 'blue') {
              ball.vy += BOOST_FORCE;
              boostUsed[ball.id] = true;
              showMessage('BOOST!', 'blue');
              break;
          } else if (direction === 'r_left' && ball.team === 'red') {
              ball.vx -= BOOST_FORCE;
              boostUsed[ball.id] = true;
              showMessage('BOOST!', 'red');
              break;
          } else if (direction === 'r_right' && ball.team === 'red') {
              ball.vx += BOOST_FORCE;
              boostUsed[ball.id] = true;
              showMessage('BOOST!', 'red');
              break;
          } else if (direction === 'r_up' && ball.team === 'red') {
              ball.vy -= BOOST_FORCE;
              boostUsed[ball.id] = true;
              showMessage('BOOST!', 'red');
              break;
          } else if (direction === 'r_down' && ball.team === 'red') {
              ball.vy += BOOST_FORCE;
              boostUsed[ball.id] = true;
              showMessage('BOOST!', 'red');
              break;
          }
      }
      // updateBoostButtons();
  }

  function updateBoostButtons() {
      let canBoostRed = false;
      let canBoostBlue = false;

      for (const ball of activeBalls) {
          if (!ball.active || boostUsed[ball.id] || ball.y > BOOST_LINE || ball.y < BOOST_LINE_UPPER) continue;

          if (ball.team === 'red') {
              canBoostRed = true;
          } else if (ball.team === 'blue') {
              canBoostBlue = true;
          }
      }

    document.getElementById('redBoostBtn').disabled = !canBoostRed;
    document.getElementById('blueBoostBtn').disabled = !canBoostBlue;
  }


  function reset() {
      activeBalls = [];
      boostUsed = {};
      redBalance = 500;
      blueBalance = 500;
      pot = 0;
      updateUI();
  }

  function setBalance() {
      const amount = parseInt(document.getElementById('house-amount').value) || 0;
      const team = document.getElementById('house-teams').value;

      if (team === 'red') {
          redBalance = amount;
      } else if (team === 'blue') {
          blueBalance = amount;
      }
      updateUI();
  }

  function updateUI() {
      document.getElementById('redBalance').textContent = '$' + redBalance;
      document.getElementById('blueBalance').textContent = '$' + blueBalance;
      document.getElementById('potAmount').textContent = '$' + pot;
      document.getElementById('house-bal').textContent = '$' + houseTotal;

      const bet = Math.max(1, parseInt(document.getElementById('betAmount').value) || 100);
      const dropBtn = document.getElementById('dropBtn');

      dropBtn.disabled = activeBalls.length > 0 ||
          redBalance < bet ||
          blueBalance < bet;

      dropBtn.innerHTML = `Start Round ($<span id="betDisplay">${bet}</span> each)`;

      if (activeBalls.length === 0) {
          //document.getElementById('redBoostBtn').disabled = true;
          //document.getElementById('blueBoostBtn').disabled = true;

          if (isAnimationRunning) {
              stopAnimation();
          }
      }
  }

  function drawPegs() {
      pegs.forEach(peg => {
          ctx.beginPath();
          ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);
          ctx.fillStyle = '#4ecdc4';
          ctx.fill();
          ctx.strokeStyle = '#defa70';
          ctx.lineWidth = 2;
          ctx.stroke();
      });
  }

  function drawBoostLine() {
      ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
      ctx.lineWidth = 3;
      ctx.setLineDash([10, 5]);
      ctx.beginPath();
      ctx.moveTo(0, BOOST_LINE);
      ctx.lineTo(canvas.width, BOOST_LINE);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = 'rgba(255, 255, 0, 0.7)';
      ctx.font = 'bold 14px Arial';
      ctx.fillText('', 50, BOOST_LINE - 5);
  }

  function drawBoostLineUpper() {
      ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
      ctx.lineWidth = 3;
      ctx.setLineDash([10, 5]);
      ctx.beginPath();
      ctx.moveTo(0, BOOST_LINE_UPPER);
      ctx.lineTo(canvas.width, BOOST_LINE_UPPER);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = 'rgba(255, 255, 0, 0.7)';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'left';
      ctx.fillText('BOOST ZONE', 10, BOOST_LINE_UPPER - 5);
  }

  function drawSlots() {
      const slotHeight = 60;
      const slotY = canvas.height - slotHeight;
      const slotWidth = canvas.width / slotConfig.length;

      slotConfig.forEach((slot, i) => {
          let bgColor;
          if (slot.type === 'jackpot') {
              bgColor = slot.team === 'red' ? '#ff6b6b' : '#4ecdc4';
          } else if (slot.type === 'center') {
              bgColor = '#f39c12';
          } else {
              bgColor = slot.team === 'red' ? '#994444' : '#2e7d79';
          }

          ctx.fillStyle = bgColor;
          ctx.fillRect(i * slotWidth, slotY, slotWidth, slotHeight);

          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 2;
          ctx.strokeRect(i * slotWidth, slotY, slotWidth, slotHeight);

          ctx.fillStyle = '#ffffff';
          ctx.font = slot.type === 'jackpot' ? 'bold 11px Arial' : 'bold 10px Arial';
          ctx.textAlign = 'center';

          if (slot.type === 'jackpot') {
              ctx.fillText('', i * slotWidth + slotWidth / 2, slotY + 18);
              ctx.font = 'bold 9px Arial';
              ctx.fillText('POT', i * slotWidth + slotWidth / 2, slotY + 32);
          } else if (slot.type === 'center') {
              ctx.fillText('', i * slotWidth + slotWidth / 2, slotY + 20);
              ctx.font = 'bold 9px Arial';
              ctx.fillText('50%', i * slotWidth + slotWidth / 2, slotY + 35);
          } else {
              ctx.font = 'bold 9px Arial';
              ctx.fillText(`T:${slot.takePercent}%`, i * slotWidth + slotWidth / 2, slotY + 22);
              ctx.fillText(`G:${slot.givePercent}%`, i * slotWidth + slotWidth / 2, slotY + 35);
          }
      });
  }

  function startAnimation() {
      isAnimationRunning = true;
      lastTime = performance.now();
      accumulatedTime = 0;
      animationFrameId = requestAnimationFrame(gameLoop);
  }

  function stopAnimation() {
      isAnimationRunning = false;
      if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
      }
  }

  function gameLoop(currentTime) {
      if (!isAnimationRunning) return;

      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;

      const maxDelta = 100;
      const safeDelta = Math.min(deltaTime, maxDelta);

      accumulatedTime += safeDelta;

      while (accumulatedTime >= FRAME_TIME) {
          for (const ball of activeBalls) {
              if (ball.active) {
                  ball.update(FRAME_TIME / 1000);
              }
          }
          accumulatedTime -= FRAME_TIME;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawSlots();
      drawBoostLine();
      drawBoostLineUpper();
      drawPegs();

      for (const ball of activeBalls) {
          if (ball.active) {
              ball.draw();
          }
      }

      animationFrameId = requestAnimationFrame(gameLoop);
  }

  initPegs();
  updateUI();
  startAnimation();
</script>
</body>
</html>